################################################################################
# Lambda Expressions
################################################################################

- function without a name (anonymous)
    - have to be called immediately
    - called arrow function in JS, TS, Frontend Frameworks
    - in python: lambda x : x + 1
    - in C++: https://www.youtube.com/watch?v=mWgmBBz0y8c

- have three parts: brackets, "the slash" \, "the arrow" ->
    - (\ <parameters> -> <function application>)

- a lambda that adds 5 to a number:
print $ ??? 10 == 15

- a lambda-predicate that checks whether a number is greater than 10:
print $ ??? 10 == False

- a lambda which adds three numbers:
print $ ??? 10 20 30 == 60

- What is an unary function? ???
- What is a binary function? ???
- Can you give examples? unary: ???, binary: ???

################################################################################
# Function Composition
################################################################################

Composition of f and g over x: Apply g over the result of applying f over x.

################################################################################
# Tuples (Vectors) (Ordered pairs)
################################################################################

- data structures whose size has to be explicitly stated (analogy with array in C++)
- can hold multiple types (ex. x :: (Int, String, [Double]) is a vector with 3 dimenstions)
- fst (5, 6) => 5
- snd (5, 6) => 6

Examples:
a vector with two coordinates representing a point in 2D space:
type Point2D = (Int, Int)

Now every function that accepts a Point2D will look like this:

helper :: Point2D -> Int
helper (x, y) = x + y -- this function sums up the coordinates. Notice the pattern matching!

Notice:
type String = [Char]

################################################################################
# Type classes
################################################################################

We can say that a function should accept numbers in general, not only Int or Double.

Example:

old:
helper :: Int -> Int

new:
helper :: (Num a) => a -> a

In most cases the compiler will help us. Will demostrate how this works today! (exercise 3)