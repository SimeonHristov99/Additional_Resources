1. Характеризирайте накратко структурата от данни „опашка“.
    Lecture 9, slides: 18, 19, 20.

2. Опишете накратко стратегията за търсене на път в граф в дълбочина (depth-first search).
    Lecture 10, slides: 22, 23.

3. Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на
различни видове алгебрични типове.
    Lecture 11, slides: 2, 3, 4, 7, 10, 11, 18.

4. Дайте пример за дефиниция на алгебричен тип като производен екземпляр на множество
класове. Обяснете накратко значението на тази дефиниция.
    Lecture 11, slides: 20
        - explanations for Eq, Show, Read
        - show task0.hs

5. Обяснете понятието „полиморфна функция“. Дайте два примера за полиморфни функции в
езика Haskell.
    Lecture 12, slides: 2
        - show in ghci; :t length
            - the a has no boundary
        - example2: head
        - generic functions:
            - the a has a boundary
            - example1: (+)
            - example2: sum

6. Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас.
    Lecture 12, slides: 12, 13, example: 14.
        - WRONG: колекция   от   типове,   за   които   се   поддържа   множество додефинирани операции, наречени методи.

7. Обяснете същността на „мързеливото“ оценяване (lazy evaluation) в езика Haskell. Дайте поне два примера, които
илюстрират различни аспекти на „мързеливото“ оценяване.
    Lecture 13
        - slides: 2
        - example1: take
        - example2: 3 ..

8. Структурна индукция.
    Lecture 14

f [] ys = ys
f (x:xs) ys = x : (f xs ys)

Prove that: f ys [] = ys

Proof:
    - P(ys): f ys [] = ys

    - Базов случай:
        Доказваме, че е изпълнено за P([]), т.е. f [] [] = []
            f ys=[] [] = [], понеже ys е [], това е изпълнено.

    - Инуктивна стъпка:
        Доказваме, че е вярно за P(y:ys), при предположение, че е вярно P(ys).
            f (y:ys) [] = y : f(ys [])
            f (y:ys) [] = y : P(ys) 
            f (y:ys) [] = y : ys 
            f (y:ys) [] = (y:ys)
    
    - Според индуктивното предположение е в сила f ys [] = ys
    следователно f (y:ys) [] = (y:ys)
